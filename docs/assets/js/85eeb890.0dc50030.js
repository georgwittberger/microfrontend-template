"use strict";(self.webpackChunkmicrofrontend_template_docs=self.webpackChunkmicrofrontend_template_docs||[]).push([[943],{9613:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>m});var n=r(9496);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},d=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=l(r),u=o,m=p["".concat(c,".").concat(u)]||p[u]||h[u]||a;return r?n.createElement(m,s(s({ref:t},d),{},{components:r})):n.createElement(m,s({ref:t},d))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},1048:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var n=r(7366),o=(r(9496),r(9613));const a={description:"Caching modules provided by microfrontends",sidebar_position:7},s="Caching Modules",i={unversionedId:"concepts/caching-modules",id:"concepts/caching-modules",title:"Caching Modules",description:"Caching modules provided by microfrontends",source:"@site/docs/concepts/caching-modules.md",sourceDirName:"concepts",slug:"/concepts/caching-modules",permalink:"/microfrontend-template/concepts/caching-modules",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{description:"Caching modules provided by microfrontends",sidebar_position:7},sidebar:"sidebar",previous:{title:"Shared Libraries",permalink:"/microfrontend-template/concepts/shared-libraries"},next:{title:"Stylesheets",permalink:"/microfrontend-template/concepts/stylesheets"}},c={},l=[{value:"Motivation",id:"motivation",level:2},{value:"Approaches",id:"approaches",level:2},{value:"Persistent URL and HTTP Caching",id:"persistent-url-and-http-caching",level:3},{value:"Hashed URL and Eternal Caching",id:"hashed-url-and-eternal-caching",level:3}],d={toc:l},p="wrapper";function h(e){let{components:t,...r}=e;return(0,o.kt)(p,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"caching-modules"},"Caching Modules"),(0,o.kt)("h2",{id:"motivation"},"Motivation"),(0,o.kt)("p",null,"If users access a web application regularly it becomes inefficient to transfer all JavaScript und CSS resources on every visit given they have not changed. For faster loading times and avoiding unnecessary data transfer it is desirable to have browsers reuse JavaScript and CSS files they have already downloaded on a previous visit."),(0,o.kt)("h2",{id:"approaches"},"Approaches"),(0,o.kt)("p",null,"All common approaches utilize the browser's ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching"},"HTTP caching")," support. However, they differ in two aspects."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Does the browser have to request the server even if it has a cached resource?"),(0,o.kt)("li",{parentName:"ul"},"Does the URL of a certain resource change when its content changes?")),(0,o.kt)("h3",{id:"persistent-url-and-http-caching"},"Persistent URL and HTTP Caching"),(0,o.kt)("p",null,"In this approach the URL of a resource does not change when it is updated on the server. Caching is accomplished by setting HTTP headers in the responses of microfrontend modules as follows."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Cache-Control: no-cache\nLast-Modified: Tue, 22 Feb 2022 20:20:20 GMT\nETag: AAPuIbAOdvAGEETbgAAAAAAABAAE\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Cache-Control: no-cache")," header tells the browser that it is allowed to store resources in its private cache but it must revalidate them with a server request before reusing them. ",(0,o.kt)("inlineCode",{parentName:"p"},"Last-Modified")," indicates the date when the content in the response was generated on the server. ",(0,o.kt)("inlineCode",{parentName:"p"},"ETag")," is a hash of the content in the response."),(0,o.kt)("p",null,"In the revalidation request the browser sends a ",(0,o.kt)("inlineCode",{parentName:"p"},"If-Modified-Since")," header if ",(0,o.kt)("inlineCode",{parentName:"p"},"Last-Modified")," was in the response and a ",(0,o.kt)("inlineCode",{parentName:"p"},"If-None-Match")," header if ",(0,o.kt)("inlineCode",{parentName:"p"},"ETag")," was in the response. The server checks whether the resource has changed since the given date or if its content produces a different hash. If the resource is still the same the server responds with status code ",(0,o.kt)("inlineCode",{parentName:"p"},"304 Not Modified")," and does not send any content. The browser uses its cached resource. Otherwise, the server sends the new content in the revalidation response."),(0,o.kt)("p",null,"The benefit of this approach is that host applications do not have to adjust any import URLs or import maps when new microfrontend versions are deployed. It is also fairly easy to set up because almost every web server supports ",(0,o.kt)("inlineCode",{parentName:"p"},"Last-Modified")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"ETag")," for static resources."),(0,o.kt)("p",null,"The caveat is that browsers have to send a server request for revalidation every time the microfrontend resource is required on a subsequent page visit. This can slightly delay rendering of microfrontends even when users have a fresh resource in their browser cache."),(0,o.kt)("p",null,"This approach may be easier to start with as long as you have control over HTTP caching headers in responses of microfrontend resources."),(0,o.kt)("h3",{id:"hashed-url-and-eternal-caching"},"Hashed URL and Eternal Caching"),(0,o.kt)("p",null,'In this approach - also known as "Cache busting" - the URL of a resource changes every time it is updated on the server. Since this results in a new address for every version of the resource its content can be cached forever in the browser. This is accomplished by setting HTTP headers in the responses of microfrontend modules as follows.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Cache-Control: public, max-age=31536000, immutable\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Cache-Control")," header tells the browser and intermediate gateways that resources can be stored in caches and reused without any revalidation. It is a promise that the content delivered by this particular URL is never going to change in the future. Once such a resource is cached in the browser it is reused instantly on every subsequent page visit."),(0,o.kt)("p",null,"The benefit of this approach is that it does not require any server requests for revalidation once users have the microfrontend resources locally. Microfrontends are rendered almost instantly in this case."),(0,o.kt)("p",null,"The caveat is that import URLs or import maps must be updated every time a microfrontend deploys a new version. Deployment setup is more complicated. The authors of ",(0,o.kt)("a",{parentName:"p",href:"https://single-spa.js.org/docs/recommended-setup#deployment-and-continuous-integration-ci"},"single-spa describe some solutions")," to the problem."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Host applications use import maps for microfrontend modules as well. Deployments of microfrontends must invoke the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/single-spa/import-map-deployer"},"import-map-deployer")," service which you have to set up in your production environment to update import maps in a concurrent-safe way."),(0,o.kt)("li",{parentName:"ul"},"Host applications use persistent URLs for microfrontend modules but these resource addresses redirect to the latest hashed URL via status code ",(0,o.kt)("inlineCode",{parentName:"li"},"302 Found"),". Therefore, host applications do not have to adjust anything when new microfrontend versions are deployed. Deployments of microfrontends must take care of updating the redirect target URL of their canonical module address.")),(0,o.kt)("p",null,"This approach may be suitable if you really want to avoid revalidation requests or you cannot control HTTP caching headers in responses of microfrontend resources, e.g. because you are using a CDN."))}h.isMDXComponent=!0}}]);